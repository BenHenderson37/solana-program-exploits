use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    program_pack::{Pack, IsInitialized}
};
use std::str::FromStr;

 
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct UserAccount {
    pub balance: u8,
    pub amount_withdrawn: u8,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct AdminAccount {
    pub balance: u8
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct ConfigAccount {
    pub admin: String,
    pub balance: u8
}

entrypoint!(process_instruction); 

 
pub fn process_instruction(
    program_id: &Pubkey,  
    accounts: &[AccountInfo],  
    _instruction_data: &[u8],  
) -> ProgramResult {
    let is_admin: bool = _instruction_data[0] == 1;
    let amount: u8 = _instruction_data[1];

    let accounts_iter = &mut accounts.iter();

    let user_wallet_account = next_account_info(accounts_iter)?;

    let mut user_wallet_data = UserAccount::try_from_slice(&user_wallet_account.data.borrow())?;

    if user_wallet_account.owner != program_id {
        msg!("Greeted account does not have the correct program id");
        return Err(ProgramError::IncorrectProgramId);
    }

    msg!("Is Admin? {:?}", is_admin);
    msg!("Amount: {:?}", amount);

    if is_admin {

        let admin_wallet_account = next_account_info(accounts_iter)?;
        let config_account = next_account_info(accounts_iter)?;

        let mut config_data = ConfigAccount::try_from_slice(&config_account.data.borrow())?;

        let admin_pubkey: Pubkey = Pubkey::from_str(&config_data.admin).unwrap();

        if *admin_wallet_account.key != admin_pubkey {
            return Err(ProgramError::InvalidAccountData);
        }

        let mut admin_wallet_data = AdminAccount::try_from_slice(&admin_wallet_account.data.borrow())?;

        user_wallet_data.balance += amount;
        user_wallet_data.serialize(&mut &mut user_wallet_account.data.borrow_mut()[..])?;

    }else{

        let fee: u8 = 10;

        msg!("User Balance: {:?}", user_wallet_data.balance);
        msg!("Amount to Withdraw (plus fee): {:?}", amount + fee);
    
        if amount + fee > user_wallet_data.balance {
            return Err(ProgramError::InsufficientFunds);
        }
    
        user_wallet_data.balance -= amount + fee;
        user_wallet_data.amount_withdrawn = amount;
        user_wallet_data.serialize(&mut &mut user_wallet_account.data.borrow_mut()[..])?;
    }

    
    

    Ok(())
}
